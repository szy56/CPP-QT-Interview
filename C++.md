# 模板类

C++模板类是一种泛型编程技术，它可以让类的数据类型参数化，从而实现多种类型的复用。像STL里的vector、list、stack等都是使用的模板类。

# 模板函数与模板类的区别

模板函数是一种函数，参数类型或返回值类型可以由模板来确定；模板类是一种类，类里的成员或成员函数类型可以由模板参数确定；

模板函数可以被重载，模板类不能被重载但是可以被特化；

模板函数可以隐式地实例化，即编译器可以根据调用时地实参类型自动推断模板参数类型，模板类必须被显式实例化。

# 引用与指针的区别

指针是一个变量，存储的是一个地址，引用时变量的别名；

指针可以有多级，引用只能有一级；

指针可以为空，引用不能为空且定义时必须被初始化；

指针可以在初始化后改变指向，引用不行；

参数传递时，指针作为参数是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量不会影响实参，引用却可以

**需要返回函数局部变量内存时用指针。对栈空间比较敏感的时候用引用。类对象作为参数传递时使用引用。**

# 服务器socket编程流程

**TCP：**

1.创建socket，用socket（）函数

2.将套接字绑定到本地地址和一个端口上，用bind()

3.将套接字设置为监听模式，使用listen()函数

4.等待客户请求到来；当请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字，用函数`accept()`。

5.用返回的套接字和客户端进行通信，用函数`send()`和`recv()`，或者`read()`和`write()`。

6.关闭网络连接

7.关闭监听

**UDP**：

1.创建socket，用socket（）函数

2.将套接字绑定到本地地址和一个端口上，用bind()

3.发送数据

4.接收数据

5.关闭网络连接

# 客户端socket编程流程

1.加载套接字库

2.设置服务器IP和端口号，sockaddr_in()

3.连接服务器，用connect()

4.用返回的套接字进行通信,send(),recv(),read(),write()

5.关闭连接

# C和C++的区别

1.C++有新增的语法和关键字，语法的区别有头文件的不同和命名空间的不同，C++允许我们有自己的命名空间；关键字方面C++管理内存的关键字与C不同，C++在malloc和free的基础上增加了new和delete，C++还有引用的概念，增加了auto，explicit一些关键字。

2.C++有虚函数和重载的概念，C不支持重载，主要是因为C++函数名字修饰与C不同，C++函数名修饰会将参数加在后面如:int func(int a,int b)  _func_int_int；C++还有虚函数的概念用于实现多态；

3.C的struct和C++的class也有不同，C++中对struct增加了访问权限，

4.C++有模板，提供了STL标准库

# 重载和重写的区别

重载是指在同一访问区内被声明的几个具有不同参数列表的同名函数，依赖于C++函数名字的修饰方式会将参数加在后面，可以是参数类型、个数、顺序的不同，不关心返回值

重写是指派生类重新定义父类中出来函数体以外完全相同的与函数，注意被重写的函数不能是static的，一定是虚函数，且返回值、函数名、参数列表都要一样，访问修饰符可以不同。

# C++类对象什么时候会调用拷贝构造函数

1.使用一个已经创建完毕的对象来初始化另一个对象

2.值传递的方式给函数参数传值

3.以值的形式返回局部对象

# 野指针和悬空指针

野指针是指没有被初始化的指针。定义指针没有初始化，指针指向的内存被释放了，或者访问越界

悬空指针是指指针最初指向的内存被释放了。delete之后没有至NULL

# QT信号槽
1.为何要有信号槽（信号槽的优势）：在Gui编程中，对象间通信是核心需求，传统的回调函数存在明显的缺陷，如：耦合度高（回调函数需要调用方知道被调用的具体函数信息），类型不安全（回调函数的参数类型、个数无法在编译期间严格校验，容易出现运行时错误），管理困难（一个事件通知多个对象时，需要手动管理回调列表）。信号槽正是为了解决这些问题诞生的，它是一种耦合度低、类型安全、可扩展、线程安全的对象间通信机制。

2.信号槽定义：信号槽是QT框架基于元对象系统实现的一种耦合度低、类型安全、可扩展的对象间通信机制。核心逻辑是：当某个对象状态发生改变（如按钮被点击）时，该对象发出一个“信号”，预先与该信号关联的“槽”函数会被自动调用，从而实现对象间事件的响应与通信

3.优势：松耦合性（信号发送者不关心接收者的信息，信号的接收者也不关心信号来自哪里，只实现自己的槽逻辑，两者仅通过connect函数建立关联，彼此独立，修改一方代码不会影响另一方）；类型安全，信号槽的参数类型、个数在编译期间会进行校验，不匹配会直接编译报错，避免运行时类型错误；支持多对多、一对多、多对一关联；线程安全，信号槽内置多种连接类型，自动处理跨线程通信的线程切换，无需手动管理事件循环、加锁、线程同步，避免线程安全问题。

# 信号槽是如何实现线程安全的
它的线程安全是针对跨线程调用场景做了专门的设计，并不能解决所有线程安全问题（比如共享数据读写）。核心逻辑：通过不同的连接类型，控制槽函数执行的时机，让槽函数始终在接收者线程中执行，而非直接跨线程调用。

QT的QObject子类都有一个“线程归属”（thread()获取）,元对象系统会感知每个对象所在线程：当信号发送时，QT会对比发送者线程和接收者线程是否为同一个，再根据连接类型决定槽函数的执行方式（直接调用/封装成事件投递）。

# 连接方式有哪几种呢
1.Qt::DirectConnection(直接连接)，信号触发时，立即在发送者线程中直接调用槽函数;
2.Qt::QueueConnection(队列连接)，跨线程时，QT会将“槽函数调用+参数”封装成一个事件，投递到接收者线程的事件循环里，接收者事件循环处理该事件时，才会执行槽函数
3.Qt::BlockingQueueConnection(阻塞队列连接)，逻辑同队列连接，但发送者线程会阻塞，直到接收者线程执行完槽函数;
4.Qt::AutoConnection(默认),自动判断，同线程->直接连接，跨线程->队列连接。

# 元对象系统
Qt的元对象系统主要用于对象间通信（信号槽）、运行时类型信息和动态属性管理。它通过信号槽机制实现了高效的事件处理和动态功能扩展。
元对象系统基于以下三个方面：1.QObject类为所有支持元对象功能的基类；2.Q_OBJECT宏，启用元对象功能，如信号、槽和动态属性；3.Meat-Object Complier(Moc)解析包含Q_OBJECT宏的类的声明，并生成支持元对象功能的代码。

# 属性系统
Qt中属性系统是一种机制，允许开发者在对象中定义属性，这些属性可以在运行时被查询和修改。Qt属性系统还支持动态特性，如运行时类型信息和动态属性的添加、查询和修改。

使用属性系统的类必须继承于QObject并使用Q_OBJECT宏声明。

 Q_PROPERTY()可以声明属性，其中名称和读方法(若为指定成员变量)是必须的参数，若指定成员变量则直接匹配该成员变量对应的读方法和写方法
 Q_PROPERTY(type name   //属性类型、名称
           (READ getFunction [WRITE setFunction] |
            MEMBER memberName [(READ getFunction | WRITE setFunction)]) //读方法 成员变量名称 写方法
           [RESET resetFunction]    //重置函数
           [NOTIFY notifySignal]    //属性值改变时通知信号
           [REVISION int | REVISION(int[, int])]    //属性版本号
           [DESIGNABLE bool]    //Qt Designer中是否可见
           [SCRIPTABLE bool]    //是否可在脚本访问
           [STORED bool]    //是否持久化存储
           [USER bool]      //是否为用户可编辑属性
           [BINDABLE bindableProperty]  //高级属性绑定
           [CONSTANT]   //是否为常量
           [FINAL]  //是否可被子类重写
           [REQUIRED])  //是否为必须的

动态属性是指运行时可以对类对象添加、删除、修改属性的机制，无需在类定义阶段声明。主要使用setProperty()/property()两个接口。

# 对象模型
标准 C++ 对象模型为面向对象范式提供了极高效率的运行时支持，但它的静态特性在部分问题领域中缺乏灵活性。图形用户界面（GUI）编程恰恰是一类既要求运行时效率、又要求高度灵活性的领域。Qt 则通过将 C++ 的执行速度与 Qt 对象模型的灵活性相结合，满足了这一核心需求。

标准 C++ 对象模型的核心是「静态高效」：类型检查、方法调用、内存布局等都在编译期确定，运行时几乎无额外开销，但缺乏动态性（比如无法在运行时动态查询类的属性、无法动态绑定方法）。

Qt 对象模型是对标准 C++ 对象模型的扩展：它完全基于标准 C++ 语法（不依赖任何非标准编译器特性），通过「元对象系统」为 C++ 对象补充了动态特性，同时保留了 C++ 的运行时效率 —— 专门适配 GUI 编程「既需要执行速度，又需要高度灵活性」的核心需求。

Qt对象模型的一些特性：信号槽、对象属性系统、强大的事件与事件过滤机制、用于国际化开发的上下文相关字符串翻译能力、定时器、对象树结构、受保护指针（引用对象销毁时自动置空）、可跨库边界生效的动态类型转换机制、对自定义类型创建的支持。

# C++内存区域
栈、堆、全局静态存储区、常量存储、代码

# 虚拟地址空间
栈、文件映射、堆、BSS、数据段、代码段

# 编译过程
1.预处理
展开宏定义、处理条件编译指令（#ifdef、#ifndef、#if、#endif等）、包含头文件，将头文件内容插入到源文件中，删除注释，添加行号与文件名标识，便于编译时产生调试信息和错误信息，预处理后的文件通常以.i或.ii为后缀(C++通常为.ii)
2.编译
将预处理后的文件进行一系列处理，包括词法分析、语法分析、语义分析、中间代码生成和优化，最终生成汇编代码，主要以.s为扩展名
3.汇编
将汇编代码转换成机器可以执行的指令，即目标代码，以.o为结尾
4.链接
将多个目标文件以及所需库文件链接在一起生成一个可执行文件或库文件
## 动态链接
运行时才加载所需要的库。
*优点*：可执行文件体积小，多个程序可共享同一个库，节省内存，库更新方便。
*缺点*：运行时依赖库文件，如果库文件缺失或版本不兼容，程序无法运行；运行时加载库会有轻微的性能损失。
## 静态链接
编译阶段将库的代码直接复制到最终的可执行文件中。可执行文件不依赖外部库文件。
*优点*：可执行文件独立，运行速度快。
*缺点*：可执行文件体积大，多个程序使用相同库时内存浪费，更新某个库需要重新编译整个程序。

# 多态
指通过相同接口调用不同的实现。多态性允许我们以统一的方式处理不同的对象，提高了代码的可用性和可扩展性。
## 静态多态(编译阶段)
1.函数重载实现和运算符重载实现；函数重载只关心参数个数、参数类型、参数顺序
2.通过模板实现，也称泛型编程。编译器会根据调用时实际类型参数生成具体函数版本或类
## 动态多态(运行多态)
通过继承和虚函数实现。基类函数加virtual关键字，在派生类中重写，运行时会根据对象的类型调用相应的函数。编译过程中会生成虚函数表，运行时，对象创建时，会创建虚表指针，指向虚函数表，该表记录虚函数地址，根据对象指针或引用指向的实际对象，从虚表中找到对应的函数进行调用
## 类大小分析
如果有虚函数，会存在虚表指针(构造函数初始化),64位8字节，32位4字节。
## 基类析构为什么要是虚函数
避免调用不到子类对象的析构函数。原因：非虚析构情况下，编译器根据指针静态类型来确定调用哪个析构函数，而不是根据动态类型(即指针实际指向的对象)。虚析构情况下，会先调用具体指向对象的析构函数，如果是子类对象，则先调用子类析构，再调用父类析构。
## 虚函数、虚函数表、虚表指针在哪块内存区域
虚函数在代码段；虚函数表在常量数据区；虚表指针在堆。
## 虚函数表创建时机
虚函数表会在编译阶段生成。
## 虚函数表指针创建时机
类对象构造时，在构造函数中，将虚函数表地址赋值给对象的虚表指针；
继承情况下，先调用基类构造函数，将基类的虚函数表地址赋值给虚表指针，再调用子类构造函数时，将子类的虚函数表地址复制给虚表指针。

# volatile
禁止编译器优化：防止编译器将变量缓存到寄存器，每次访问必须从内存中读取；
保证访问顺序：编译器不会对volatile变量的访问进行重新排序；
volatile不保证原子性；
volatile与const结合表示变量是只读的，但可能被外部因素改变

# const和static
## const
*修饰变量*：变量值不可被修改
*常量指针*：不能通过指针修改值，但可改变指针指向，const *      (左定值，右定向)
*指针常量*：不能改变指针指向，但可改变指向对象的值，* const
*修饰引用*：不能通过引用修改该值
*修饰成员函数*：不能修改类的成员变量，相当于修饰了成员函数中隐藏的this指针
## static
作用主要是改变函数、对象的作用域和可见性。
*修饰局部变量*：在函数体内，静态局部变量在程序执行到该对象的声明处时被首次初始化，且只被初始化一次，之后每次调用函数不在进行初始化，而是保留上次函数调用时的值。静态局部变量在函数调用结束后不会销毁，而是到程序结束才销毁。
*静态全局变量*：静态全局变量在它声明的整个文件内是可见的，而在文件外是不可见的。
*静态函数*：静态函数与静态全局变量类似，只能在定义它的文件中使用，其他文件不能被调用。
*静态成员变量*：在类中，静态成员变量属于整个类，而不是某个对象，所有类对象共享静态成员变量。类的静态成员变量必须在类外进行定义和初始化，否则不能使用。
*静态成员函数*：该函数属于整个类，且没有this指针，也就是无法访问非静态成员变量和非静态成员函数，只能访问静态成员变量和静态成员函数。静态成员函数不能为虚函数，因为虚函数是通过对象来进行调用，每个对象都有一个虚表指针，而静态成员函数属于整个类，不依赖于任何对象，所以不能为虚函数。
