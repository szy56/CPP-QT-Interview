# 模板类

C++模板类是一种泛型编程技术，它可以让类的数据类型参数化，从而实现多种类型的复用。像STL里的vector、list、stack等都是使用的模板类。

# 模板函数与模板类的区别

模板函数是一种函数，参数类型或返回值类型可以由模板来确定；模板类是一种类，类里的成员或成员函数类型可以由模板参数确定；

模板函数可以被重载，模板类不能被重载但是可以被特化；

模板函数可以隐式地实例化，即编译器可以根据调用时地实参类型自动推断模板参数类型，模板类必须被显式实例化。

# 引用与指针的区别

指针是一个变量，存储的是一个地址，引用时变量的别名；

指针可以有多级，引用只能有一级；

指针可以为空，引用不能为空且定义时必须被初始化；

指针可以在初始化后改变指向，引用不行；

参数传递时，指针作为参数是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量不会影响实参，引用却可以

**需要返回函数局部变量内存时用指针。对栈空间比较敏感的时候用引用。类对象作为参数传递时使用引用。**

# 服务器socket编程流程

**TCP：**

1.创建socket，用socket（）函数

2.将套接字绑定到本地地址和一个端口上，用bind()

3.将套接字设置为监听模式，使用listen()函数

4.等待客户请求到来；当请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字，用函数`accept()`。

5.用返回的套接字和客户端进行通信，用函数`send()`和`recv()`，或者`read()`和`write()`。

6.关闭网络连接

7.关闭监听

**UDP**：

1.创建socket，用socket（）函数

2.将套接字绑定到本地地址和一个端口上，用bind()

3.发送数据

4.接收数据

5.关闭网络连接

# 客户端socket编程流程

1.加载套接字库

2.设置服务器IP和端口号，sockaddr_in()

3.连接服务器，用connect()

4.用返回的套接字进行通信,send(),recv(),read(),write()

5.关闭连接

# C和C++的区别

1.C++有新增的语法和关键字，语法的区别有头文件的不同和命名空间的不同，C++允许我们有自己的命名空间；关键字方面C++管理内存的关键字与C不同，C++在malloc和free的基础上增加了new和delete，C++还有引用的概念，增加了auto，explicit一些关键字。

2.C++有虚函数和重载的概念，C不支持重载，主要是因为C++函数名字修饰与C不同，C++函数名修饰会将参数加在后面如:int func(int a,int b)  _func_int_int；C++还有虚函数的概念用于实现多态；

3.C的struct和C++的class也有不同，C++中对struct增加了访问权限，

4.C++有模板，提供了STL标准库

# 重载和重写的区别

重载是指在同一访问区内被声明的几个具有不同参数列表的同名函数，依赖于C++函数名字的修饰方式会将参数加在后面，可以是参数类型、个数、顺序的不同，不关心返回值

重写是指派生类重新定义父类中出来函数体以外完全相同的与函数，注意被重写的函数不能是static的，一定是虚函数，且返回值、函数名、参数列表都要一样，访问修饰符可以不同。

# C++类对象什么时候会调用拷贝构造函数

1.使用一个已经创建完毕的对象来初始化另一个对象

2.值传递的方式给函数参数传值

3.以值的形式返回局部对象

# 野指针和悬空指针

野指针是指没有被初始化的指针。定义指针没有初始化，指针指向的内存被释放了，或者访问越界

悬空指针是指指针最初指向的内存被释放了。delete之后没有至NULL

# QT信号槽
1.为何要有信号槽（信号槽的优势）：在Gui编程中，对象间通信是核心需求，传统的回调函数存在明显的缺陷，如：耦合度高（回调函数需要调用方知道被调用的具体函数信息），类型不安全（回调函数的参数类型、个数无法在编译期间严格校验，容易出现运行时错误），管理困难（一个事件通知多个对象时，需要手动管理回调列表）。信号槽正是为了解决这些问题诞生的，它是一种耦合度低、类型安全、可扩展、线程安全的对象间通信机制。

2.信号槽定义：信号槽是QT框架基于元对象系统实现的一种耦合度低、类型安全、可扩展的对象间通信机制。核心逻辑是：当某个对象状态发生改变（如按钮被点击）时，该对象发出一个“信号”，预先与该信号关联的“槽”函数会被自动调用，从而实现对象间事件的响应与通信

3.优势：松耦合性（信号发送者不关心接收者的信息，信号的接收者也不关心信号来自哪里，只实现自己的槽逻辑，两者仅通过connect函数建立关联，彼此独立，修改一方代码不会影响另一方）；类型安全，信号槽的参数类型、个数在编译期间会进行校验，不匹配会直接编译报错，避免运行时类型错误；支持多对多、一对多、多对一关联；线程安全，信号槽内置多种连接类型，自动处理跨线程通信的线程切换，无需手动管理事件循环、加锁、线程同步，避免线程安全问题。

# 信号槽是如何实现线程安全的
它的线程安全是针对跨线程调用场景做了专门的设计，并不能解决所有线程安全问题（比如共享数据读写）。核心逻辑：通过不同的连接类型，控制槽函数执行的时机，让槽函数始终在接收者线程中执行，而非直接跨线程调用。

QT的QObject子类都有一个“线程归属”（thread()获取）,元对象系统会感知每个对象所在线程：当信号发送时，QT会对比发送者线程和接收者线程是否为同一个，再根据连接类型决定槽函数的执行方式（直接调用/封装成事件投递）。

# 连接方式有哪几种呢
1.Qt::DirectConnection(直接连接)，信号触发时，立即在发送者线程中直接调用槽函数;
2.Qt::QueueConnection(队列连接)，跨线程时，QT会将“槽函数调用+参数”封装成一个事件，投递到接收者线程的事件循环里，接收者事件循环处理该事件时，才会执行槽函数
3.Qt::BlockingQueueConnection(阻塞队列连接)，逻辑同队列连接，但发送者线程会阻塞，知道接收者线程执行完槽函数;
4.Qt::AutoConnection(默认),自动判断，同线程->直接连接，跨线程->队列连接。
